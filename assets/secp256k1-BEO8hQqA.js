import{H as de,a as le,t as he,b as we,d as zt,e as pe,f as ge,g as ye,r as me,s as Ee}from"./index-Bl8T66rD.js";class Ut extends de{constructor(r,t){super(),this.finished=!1,this.destroyed=!1,le(r);const n=he(t);if(this.iHash=r.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?r.create().update(n).digest():n);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=r.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),we(s)}update(r){return zt(this),this.iHash.update(r),this}digestInto(r){zt(this),pe(r,this.outputLen),this.finished=!0,this.iHash.digestInto(r),this.oHash.update(r),this.oHash.digestInto(r),this.destroy()}digest(){const r=new Uint8Array(this.oHash.outputLen);return this.digestInto(r),r}_cloneInto(r){r||(r=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:a,outputLen:f}=this;return r=r,r.finished=i,r.destroyed=s,r.blockLen=a,r.outputLen=f,r.oHash=t._cloneInto(r.oHash),r.iHash=n._cloneInto(r.iHash),r}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Tt=(e,r,t)=>new Ut(e,r).update(t).digest();Tt.create=(e,r)=>new Ut(e,r);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Et=BigInt(0),bt=BigInt(1);function at(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function vt(e){if(!at(e))throw new Error("Uint8Array expected")}function ct(e,r){if(typeof r!="boolean")throw new Error(e+" boolean expected, got "+r)}function lt(e){const r=e.toString(16);return r.length&1?"0"+r:r}function Ct(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Et:BigInt("0x"+e)}const Vt=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",be=Array.from({length:256},(e,r)=>r.toString(16).padStart(2,"0"));function ut(e){if(vt(e),Vt)return e.toHex();let r="";for(let t=0;t<e.length;t++)r+=be[e[t]];return r}const G={_0:48,_9:57,A:65,F:70,a:97,f:102};function jt(e){if(e>=G._0&&e<=G._9)return e-G._0;if(e>=G.A&&e<=G.F)return e-(G.A-10);if(e>=G.a&&e<=G.f)return e-(G.a-10)}function ht(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Vt)return Uint8Array.fromHex(e);const r=e.length,t=r/2;if(r%2)throw new Error("hex string expected, got unpadded hex of length "+r);const n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const a=jt(e.charCodeAt(s)),f=jt(e.charCodeAt(s+1));if(a===void 0||f===void 0){const o=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}n[i]=a*16+f}return n}function et(e){return Ct(ut(e))}function Dt(e){return vt(e),Ct(ut(Uint8Array.from(e).reverse()))}function dt(e,r){return ht(e.toString(16).padStart(r*2,"0"))}function Kt(e,r){return dt(e,r).reverse()}function D(e,r,t){let n;if(typeof r=="string")try{n=ht(r)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(at(r))n=Uint8Array.from(r);else throw new Error(e+" must be hex string or Uint8Array");const i=n.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return n}function wt(...e){let r=0;for(let n=0;n<e.length;n++){const i=e[n];vt(i),r+=i.length}const t=new Uint8Array(r);for(let n=0,i=0;n<e.length;n++){const s=e[n];t.set(s,i),i+=s.length}return t}const Bt=e=>typeof e=="bigint"&&Et<=e;function xt(e,r,t){return Bt(e)&&Bt(r)&&Bt(t)&&r<=e&&e<t}function it(e,r,t,n){if(!xt(r,t,n))throw new Error("expected valid "+e+": "+t+" <= n < "+n+", got "+r)}function ve(e){let r;for(r=0;e>Et;e>>=bt,r+=1);return r}const pt=e=>(bt<<BigInt(e))-bt,St=e=>new Uint8Array(e),Yt=e=>Uint8Array.from(e);function Be(e,r,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof r!="number"||r<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=St(e),i=St(e),s=0;const a=()=>{n.fill(1),i.fill(0),s=0},f=(...h)=>t(i,n,...h),o=(h=St(0))=>{i=f(Yt([0]),h),n=f(),h.length!==0&&(i=f(Yt([1]),h),n=f())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const I=[];for(;h<r;){n=f();const R=n.slice();I.push(R),h+=n.length}return wt(...I)};return(h,I)=>{a(),o(h);let R;for(;!(R=I(l()));)o();return a(),R}}const xe={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||at(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,r)=>r.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function gt(e,r,t={}){const n=(i,s,a)=>{const f=xe[s];if(typeof f!="function")throw new Error("invalid validator function");const o=e[i];if(!(a&&o===void 0)&&!f(o,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(r))n(i,s,!1);for(const[i,s]of Object.entries(t))n(i,s,!0);return e}function Wt(e){const r=new WeakMap;return(t,...n)=>{const i=r.get(t);if(i!==void 0)return i;const s=e(t,...n);return r.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),T=BigInt(1),rt=BigInt(2),Se=BigInt(3),Mt=BigInt(4),Gt=BigInt(5),$t=BigInt(8);function V(e,r){const t=e%r;return t>=C?t:r+t}function K(e,r,t){let n=e;for(;r-- >C;)n*=n,n%=t;return n}function At(e,r){if(e===C)throw new Error("invert: expected non-zero number");if(r<=C)throw new Error("invert: expected positive modulus, got "+r);let t=V(e,r),n=r,i=C,s=T;for(;t!==C;){const a=n/t,f=n%t,o=i-s*a;n=t,t=f,i=s,s=o}if(n!==T)throw new Error("invert: does not exist");return V(i,r)}function Jt(e,r){const t=(e.ORDER+T)/Mt,n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}function Ae(e,r){const t=(e.ORDER-Gt)/$t,n=e.mul(r,rt),i=e.pow(n,t),s=e.mul(r,i),a=e.mul(e.mul(s,rt),i),f=e.mul(s,e.sub(a,e.ONE));if(!e.eql(e.sqr(f),r))throw new Error("Cannot find square root");return f}function Oe(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let r=e-T,t=0;for(;r%rt===C;)r/=rt,t++;let n=rt;const i=Ot(e);for(;Xt(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Jt;let s=i.pow(n,r);const a=(r+T)/rt;return function(f,o){if(f.is0(o))return o;if(Xt(f,o)!==1)throw new Error("Cannot find square root");let l=t,h=f.mul(f.ONE,s),I=f.pow(o,r),R=f.pow(o,a);for(;!f.eql(I,f.ONE);){if(f.is0(I))return f.ZERO;let L=1,k=f.sqr(I);for(;!f.eql(k,f.ONE);)if(L++,k=f.sqr(k),L===l)throw new Error("Cannot find square root");const g=T<<BigInt(l-L-1),P=f.pow(h,g);l=L,h=f.sqr(P),I=f.mul(I,h),R=f.mul(R,P)}return R}}function Ie(e){return e%Mt===Se?Jt:e%$t===Gt?Ae:Oe(e)}const Re=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ne(e){const r={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Re.reduce((n,i)=>(n[i]="function",n),r);return gt(e,t)}function qe(e,r,t){if(t<C)throw new Error("invalid exponent, negatives unsupported");if(t===C)return e.ONE;if(t===T)return r;let n=e.ONE,i=r;for(;t>C;)t&T&&(n=e.mul(n,i)),i=e.sqr(i),t>>=T;return n}function Qt(e,r,t=!1){const n=new Array(r.length).fill(t?e.ZERO:void 0),i=r.reduce((a,f,o)=>e.is0(f)?a:(n[o]=a,e.mul(a,f)),e.ONE),s=e.inv(i);return r.reduceRight((a,f,o)=>e.is0(f)?a:(n[o]=e.mul(a,n[o]),e.mul(a,f)),s),n}function Xt(e,r){const t=(e.ORDER-T)/rt,n=e.pow(r,t),i=e.eql(n,e.ONE),s=e.eql(n,e.ZERO),a=e.eql(n,e.neg(e.ONE));if(!i&&!s&&!a)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function _t(e,r){r!==void 0&&ge(r);const t=r!==void 0?r:e.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Ot(e,r,t=!1,n={}){if(e<=C)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=_t(e,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const f=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:s,MASK:pt(i),ZERO:C,ONE:T,create:o=>V(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return C<=o&&o<e},is0:o=>o===C,isOdd:o=>(o&T)===T,neg:o=>V(-o,e),eql:(o,l)=>o===l,sqr:o=>V(o*o,e),add:(o,l)=>V(o+l,e),sub:(o,l)=>V(o-l,e),mul:(o,l)=>V(o*l,e),pow:(o,l)=>qe(f,o,l),div:(o,l)=>V(o*At(l,e),e),sqrN:o=>o*o,addN:(o,l)=>o+l,subN:(o,l)=>o-l,mulN:(o,l)=>o*l,inv:o=>At(o,e),sqrt:n.sqrt||(o=>(a||(a=Ie(e)),a(f,o))),toBytes:o=>t?Kt(o,s):dt(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?Dt(o):et(o)},invertBatch:o=>Qt(f,o),cmov:(o,l,h)=>h?l:o});return Object.freeze(f)}function te(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const r=e.toString(2).length;return Math.ceil(r/8)}function ee(e){const r=te(e);return r+Math.ceil(r/2)}function He(e,r,t=!1){const n=e.length,i=te(r),s=ee(r);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const a=t?Dt(e):et(e),f=V(a,r-T)+T;return t?Kt(f,i):dt(f,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const re=BigInt(0),It=BigInt(1);function Rt(e,r){const t=r.negate();return e?t:r}function ne(e,r){if(!Number.isSafeInteger(e)||e<=0||e>r)throw new Error("invalid window size, expected [1.."+r+"], got W="+e)}function Nt(e,r){ne(e,r);const t=Math.ceil(r/e)+1,n=2**(e-1),i=2**e,s=pt(e),a=BigInt(e);return{windows:t,windowSize:n,mask:s,maxNumber:i,shiftBy:a}}function oe(e,r,t){const{windowSize:n,mask:i,maxNumber:s,shiftBy:a}=t;let f=Number(e&i),o=e>>a;f>n&&(f-=s,o+=It);const l=r*n,h=l+Math.abs(f)-1,I=f===0,R=f<0,L=r%2!==0;return{nextN:o,offset:h,isZero:I,isNeg:R,isNegF:L,offsetF:l}}function Le(e,r){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,n)=>{if(!(t instanceof r))throw new Error("invalid point at index "+n)})}function ke(e,r){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,n)=>{if(!r.isValid(t))throw new Error("invalid scalar at index "+n)})}const qt=new WeakMap,ie=new WeakMap;function Ht(e){return ie.get(e)||1}function Ze(e,r){return{constTimeNegate:Rt,hasPrecomputes(t){return Ht(t)!==1},unsafeLadder(t,n,i=e.ZERO){let s=t;for(;n>re;)n&It&&(i=i.add(s)),s=s.double(),n>>=It;return i},precomputeWindow(t,n){const{windows:i,windowSize:s}=Nt(n,r),a=[];let f=t,o=f;for(let l=0;l<i;l++){o=f,a.push(o);for(let h=1;h<s;h++)o=o.add(f),a.push(o);f=o.double()}return a},wNAF(t,n,i){let s=e.ZERO,a=e.BASE;const f=Nt(t,r);for(let o=0;o<f.windows;o++){const{nextN:l,offset:h,isZero:I,isNeg:R,isNegF:L,offsetF:k}=oe(i,o,f);i=l,I?a=a.add(Rt(L,n[k])):s=s.add(Rt(R,n[h]))}return{p:s,f:a}},wNAFUnsafe(t,n,i,s=e.ZERO){const a=Nt(t,r);for(let f=0;f<a.windows&&i!==re;f++){const{nextN:o,offset:l,isZero:h,isNeg:I}=oe(i,f,a);if(i=o,!h){const R=n[l];s=s.add(I?R.negate():R)}}return s},getPrecomputes(t,n,i){let s=qt.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&qt.set(n,i(s))),s},wNAFCached(t,n,i){const s=Ht(t);return this.wNAF(s,this.getPrecomputes(s,t,i),n)},wNAFCachedUnsafe(t,n,i,s){const a=Ht(t);return a===1?this.unsafeLadder(t,n,s):this.wNAFUnsafe(a,this.getPrecomputes(a,t,i),n,s)},setWindowSize(t,n){ne(n,r),ie.set(t,n),qt.delete(t)}}}function Fe(e,r,t,n){Le(t,e),ke(n,r);const i=t.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const a=e.ZERO,f=ve(BigInt(i));let o=1;f>12?o=f-3:f>4?o=f-2:f>0&&(o=2);const l=pt(o),h=new Array(Number(l)+1).fill(a),I=Math.floor((r.BITS-1)/o)*o;let R=a;for(let L=I;L>=0;L-=o){h.fill(a);for(let g=0;g<s;g++){const P=n[g],Z=Number(P>>BigInt(L)&l);h[Z]=h[Z].add(t[g])}let k=a;for(let g=h.length-1,P=a;g>0;g--)P=P.add(h[g]),k=k.add(P);if(R=R.add(k),L!==0)for(let g=0;g<o;g++)R=R.double()}return R}function se(e){return Ne(e.Fp),gt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._t(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function fe(e){e.lowS!==void 0&&ct("lowS",e.lowS),e.prehash!==void 0&&ct("prehash",e.prehash)}function Pe(e){const r=se(e);gt(r,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:i}=r;if(t){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...r})}class ze extends Error{constructor(r=""){super(r)}}const $={Err:ze,_tlv:{encode:(e,r)=>{const{Err:t}=$;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(r.length&1)throw new t("tlv.encode: unpadded data");const n=r.length/2,i=lt(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=n>127?lt(i.length/2|128):"";return lt(e)+s+i+r},decode(e,r){const{Err:t}=$;let n=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(r.length<2||r[n++]!==e)throw new t("tlv.decode: wrong tlv");const i=r[n++],s=!!(i&128);let a=0;if(!s)a=i;else{const o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");const l=r.subarray(n,n+o);if(l.length!==o)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const h of l)a=a<<8|h;if(n+=o,a<128)throw new t("tlv.decode(long): not minimal encoding")}const f=r.subarray(n,n+a);if(f.length!==a)throw new t("tlv.decode: wrong value length");return{v:f,l:r.subarray(n+a)}}},_int:{encode(e){const{Err:r}=$;if(e<J)throw new r("integer: negative integers are not allowed");let t=lt(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new r("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:r}=$;if(e[0]&128)throw new r("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new r("invalid signature integer: unnecessary leading zero");return et(e)}},toSig(e){const{Err:r,_int:t,_tlv:n}=$,i=D("signature",e),{v:s,l:a}=n.decode(48,i);if(a.length)throw new r("invalid signature: left bytes after parsing");const{v:f,l:o}=n.decode(2,s),{v:l,l:h}=n.decode(2,o);if(h.length)throw new r("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(l)}},hexFromSig(e){const{_tlv:r,_int:t}=$,n=r.encode(2,t.encode(e.r)),i=r.encode(2,t.encode(e.s)),s=n+i;return r.encode(48,s)}};function Lt(e,r){return ut(dt(e,r))}const J=BigInt(0),F=BigInt(1);BigInt(2);const kt=BigInt(3),Ue=BigInt(4);function Te(e){const r=Pe(e),{Fp:t}=r,n=Ot(r.n,r.nBitLength),i=r.toBytes||((B,c,w)=>{const y=c.toAffine();return wt(Uint8Array.from([4]),t.toBytes(y.x),t.toBytes(y.y))}),s=r.fromBytes||(B=>{const c=B.subarray(1),w=t.fromBytes(c.subarray(0,t.BYTES)),y=t.fromBytes(c.subarray(t.BYTES,2*t.BYTES));return{x:w,y}});function a(B){const{a:c,b:w}=r,y=t.sqr(B),v=t.mul(y,B);return t.add(t.add(v,t.mul(B,c)),w)}function f(B,c){const w=t.sqr(c),y=a(B);return t.eql(w,y)}if(!f(r.Gx,r.Gy))throw new Error("bad curve params: generator point");const o=t.mul(t.pow(r.a,kt),Ue),l=t.mul(t.sqr(r.b),BigInt(27));if(t.is0(t.add(o,l)))throw new Error("bad curve params: a or b");function h(B){return xt(B,F,r.n)}function I(B){const{allowedPrivateKeyLengths:c,nByteLength:w,wrapPrivateKey:y,n:v}=r;if(c&&typeof B!="bigint"){if(at(B)&&(B=ut(B)),typeof B!="string"||!c.includes(B.length))throw new Error("invalid private key");B=B.padStart(w*2,"0")}let O;try{O=typeof B=="bigint"?B:et(D("private key",B,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof B)}return y&&(O=V(O,v)),it("private key",O,F,v),O}function R(B){if(!(B instanceof g))throw new Error("ProjectivePoint expected")}const L=Wt((B,c)=>{const{px:w,py:y,pz:v}=B;if(t.eql(v,t.ONE))return{x:w,y};const O=B.is0();c==null&&(c=O?t.ONE:t.inv(v));const q=t.mul(w,c),N=t.mul(y,c),m=t.mul(v,c);if(O)return{x:t.ZERO,y:t.ZERO};if(!t.eql(m,t.ONE))throw new Error("invZ was invalid");return{x:q,y:N}}),k=Wt(B=>{if(B.is0()){if(r.allowInfinityPoint&&!t.is0(B.py))return;throw new Error("bad point: ZERO")}const{x:c,y:w}=B.toAffine();if(!t.isValid(c)||!t.isValid(w))throw new Error("bad point: x or y not FE");if(!f(c,w))throw new Error("bad point: equation left != right");if(!B.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(c,w,y){if(c==null||!t.isValid(c))throw new Error("x required");if(w==null||!t.isValid(w)||t.is0(w))throw new Error("y required");if(y==null||!t.isValid(y))throw new Error("z required");this.px=c,this.py=w,this.pz=y,Object.freeze(this)}static fromAffine(c){const{x:w,y}=c||{};if(!c||!t.isValid(w)||!t.isValid(y))throw new Error("invalid affine point");if(c instanceof g)throw new Error("projective point not allowed");const v=O=>t.eql(O,t.ZERO);return v(w)&&v(y)?g.ZERO:new g(w,y,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){const w=Qt(t,c.map(y=>y.pz));return c.map((y,v)=>y.toAffine(w[v])).map(g.fromAffine)}static fromHex(c){const w=g.fromAffine(s(D("pointHex",c)));return w.assertValidity(),w}static fromPrivateKey(c){return g.BASE.multiply(I(c))}static msm(c,w){return Fe(g,n,c,w)}_setWindowSize(c){W.setWindowSize(this,c)}assertValidity(){k(this)}hasEvenY(){const{y:c}=this.toAffine();if(t.isOdd)return!t.isOdd(c);throw new Error("Field doesn't support isOdd")}equals(c){R(c);const{px:w,py:y,pz:v}=this,{px:O,py:q,pz:N}=c,m=t.eql(t.mul(w,N),t.mul(O,v)),A=t.eql(t.mul(y,N),t.mul(q,v));return m&&A}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:w}=r,y=t.mul(w,kt),{px:v,py:O,pz:q}=this;let N=t.ZERO,m=t.ZERO,A=t.ZERO,E=t.mul(v,v),z=t.mul(O,O),d=t.mul(q,q),u=t.mul(v,O);return u=t.add(u,u),A=t.mul(v,q),A=t.add(A,A),N=t.mul(c,A),m=t.mul(y,d),m=t.add(N,m),N=t.sub(z,m),m=t.add(z,m),m=t.mul(N,m),N=t.mul(u,N),A=t.mul(y,A),d=t.mul(c,d),u=t.sub(E,d),u=t.mul(c,u),u=t.add(u,A),A=t.add(E,E),E=t.add(A,E),E=t.add(E,d),E=t.mul(E,u),m=t.add(m,E),d=t.mul(O,q),d=t.add(d,d),E=t.mul(d,u),N=t.sub(N,E),A=t.mul(d,z),A=t.add(A,A),A=t.add(A,A),new g(N,m,A)}add(c){R(c);const{px:w,py:y,pz:v}=this,{px:O,py:q,pz:N}=c;let m=t.ZERO,A=t.ZERO,E=t.ZERO;const z=r.a,d=t.mul(r.b,kt);let u=t.mul(w,O),p=t.mul(y,q),x=t.mul(v,N),b=t.add(w,y),S=t.add(O,q);b=t.mul(b,S),S=t.add(u,p),b=t.sub(b,S),S=t.add(w,v);let H=t.add(O,N);return S=t.mul(S,H),H=t.add(u,x),S=t.sub(S,H),H=t.add(y,v),m=t.add(q,N),H=t.mul(H,m),m=t.add(p,x),H=t.sub(H,m),E=t.mul(z,S),m=t.mul(d,x),E=t.add(m,E),m=t.sub(p,E),E=t.add(p,E),A=t.mul(m,E),p=t.add(u,u),p=t.add(p,u),x=t.mul(z,x),S=t.mul(d,S),p=t.add(p,x),x=t.sub(u,x),x=t.mul(z,x),S=t.add(S,x),u=t.mul(p,S),A=t.add(A,u),u=t.mul(H,S),m=t.mul(b,m),m=t.sub(m,u),u=t.mul(b,p),E=t.mul(H,E),E=t.add(E,u),new g(m,A,E)}subtract(c){return this.add(c.negate())}is0(){return this.equals(g.ZERO)}wNAF(c){return W.wNAFCached(this,c,g.normalizeZ)}multiplyUnsafe(c){const{endo:w,n:y}=r;it("scalar",c,J,y);const v=g.ZERO;if(c===J)return v;if(this.is0()||c===F)return this;if(!w||W.hasPrecomputes(this))return W.wNAFCachedUnsafe(this,c,g.normalizeZ);let{k1neg:O,k1:q,k2neg:N,k2:m}=w.splitScalar(c),A=v,E=v,z=this;for(;q>J||m>J;)q&F&&(A=A.add(z)),m&F&&(E=E.add(z)),z=z.double(),q>>=F,m>>=F;return O&&(A=A.negate()),N&&(E=E.negate()),E=new g(t.mul(E.px,w.beta),E.py,E.pz),A.add(E)}multiply(c){const{endo:w,n:y}=r;it("scalar",c,F,y);let v,O;if(w){const{k1neg:q,k1:N,k2neg:m,k2:A}=w.splitScalar(c);let{p:E,f:z}=this.wNAF(N),{p:d,f:u}=this.wNAF(A);E=W.constTimeNegate(q,E),d=W.constTimeNegate(m,d),d=new g(t.mul(d.px,w.beta),d.py,d.pz),v=E.add(d),O=z.add(u)}else{const{p:q,f:N}=this.wNAF(c);v=q,O=N}return g.normalizeZ([v,O])[0]}multiplyAndAddUnsafe(c,w,y){const v=g.BASE,O=(N,m)=>m===J||m===F||!N.equals(v)?N.multiplyUnsafe(m):N.multiply(m),q=O(this,w).add(O(c,y));return q.is0()?void 0:q}toAffine(c){return L(this,c)}isTorsionFree(){const{h:c,isTorsionFree:w}=r;if(c===F)return!0;if(w)return w(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:c,clearCofactor:w}=r;return c===F?this:w?w(g,this):this.multiplyUnsafe(r.h)}toRawBytes(c=!0){return ct("isCompressed",c),this.assertValidity(),i(g,this,c)}toHex(c=!0){return ct("isCompressed",c),ut(this.toRawBytes(c))}}g.BASE=new g(r.Gx,r.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:P,nBitLength:Z}=r,W=Ze(g,P?Math.ceil(Z/2):Z);return{CURVE:r,ProjectivePoint:g,normPrivateKeyToScalar:I,weierstrassEquation:a,isWithinCurveOrder:h}}function Ce(e){const r=se(e);return gt(r,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...r})}function Ve(e){const r=Ce(e),{Fp:t,n,nByteLength:i,nBitLength:s}=r,a=t.BYTES+1,f=2*t.BYTES+1;function o(d){return V(d,n)}function l(d){return At(d,n)}const{ProjectivePoint:h,normPrivateKeyToScalar:I,weierstrassEquation:R,isWithinCurveOrder:L}=Te({...r,toBytes(d,u,p){const x=u.toAffine(),b=t.toBytes(x.x),S=wt;return ct("isCompressed",p),p?S(Uint8Array.from([u.hasEvenY()?2:3]),b):S(Uint8Array.from([4]),b,t.toBytes(x.y))},fromBytes(d){const u=d.length,p=d[0],x=d.subarray(1);if(u===a&&(p===2||p===3)){const b=et(x);if(!xt(b,F,t.ORDER))throw new Error("Point is not on curve");const S=R(b);let H;try{H=t.sqrt(S)}catch(Y){const M=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+M)}const U=(H&F)===F;return(p&1)===1!==U&&(H=t.neg(H)),{x:b,y:H}}else if(u===f&&p===4){const b=t.fromBytes(x.subarray(0,t.BYTES)),S=t.fromBytes(x.subarray(t.BYTES,2*t.BYTES));return{x:b,y:S}}else{const b=a,S=f;throw new Error("invalid Point, expected length of "+b+", or uncompressed "+S+", got "+u)}}});function k(d){const u=n>>F;return d>u}function g(d){return k(d)?o(-d):d}const P=(d,u,p)=>et(d.slice(u,p));class Z{constructor(u,p,x){it("r",u,F,n),it("s",p,F,n),this.r=u,this.s=p,x!=null&&(this.recovery=x),Object.freeze(this)}static fromCompact(u){const p=i;return u=D("compactSignature",u,p*2),new Z(P(u,0,p),P(u,p,2*p))}static fromDER(u){const{r:p,s:x}=$.toSig(D("DER",u));return new Z(p,x)}assertValidity(){}addRecoveryBit(u){return new Z(this.r,this.s,u)}recoverPublicKey(u){const{r:p,s:x,recovery:b}=this,S=v(D("msgHash",u));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");const H=b===2||b===3?p+r.n:p;if(H>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const U=b&1?"03":"02",Y=h.fromHex(U+Lt(H,t.BYTES)),M=l(H),j=o(-S*M),nt=o(x*M),Q=h.BASE.multiplyAndAddUnsafe(Y,j,nt);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return k(this.s)}normalizeS(){return this.hasHighS()?new Z(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return $.hexFromSig(this)}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){const u=i;return Lt(this.r,u)+Lt(this.s,u)}}const W={isValidPrivateKey(d){try{return I(d),!0}catch{return!1}},normPrivateKeyToScalar:I,randomPrivateKey:()=>{const d=ee(r.n);return He(r.randomBytes(d),r.n)},precompute(d=8,u=h.BASE){return u._setWindowSize(d),u.multiply(BigInt(3)),u}};function B(d,u=!0){return h.fromPrivateKey(d).toRawBytes(u)}function c(d){if(typeof d=="bigint")return!1;if(d instanceof h)return!0;const u=D("key",d).length,p=t.BYTES,x=p+1,b=2*p+1;if(!(r.allowedPrivateKeyLengths||i===x))return u===x||u===b}function w(d,u,p=!0){if(c(d)===!0)throw new Error("first arg must be private key");if(c(u)===!1)throw new Error("second arg must be public key");return h.fromHex(u).multiply(I(d)).toRawBytes(p)}const y=r.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");const u=et(d),p=d.length*8-s;return p>0?u>>BigInt(p):u},v=r.bits2int_modN||function(d){return o(y(d))},O=pt(s);function q(d){return it("num < 2^"+s,d,J,O),dt(d,i)}function N(d,u,p=m){if(["recovered","canonical"].some(X=>X in p))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:b}=r;let{lowS:S,prehash:H,extraEntropy:U}=p;S==null&&(S=!0),d=D("msgHash",d),fe(p),H&&(d=D("prehashed msgHash",x(d)));const Y=v(d),M=I(u),j=[q(M),q(Y)];if(U!=null&&U!==!1){const X=U===!0?b(t.BYTES):U;j.push(D("extraEntropy",X))}const nt=wt(...j),Q=Y;function yt(X){const ot=y(X);if(!L(ot))return;const mt=l(ot),st=h.BASE.multiply(ot).toAffine(),_=o(st.x);if(_===J)return;const tt=o(mt*o(Q+_*M));if(tt===J)return;let ft=(st.x===_?0:2)|Number(st.y&F),Pt=tt;return S&&k(tt)&&(Pt=g(tt),ft^=1),new Z(_,Pt,ft)}return{seed:nt,k2sig:yt}}const m={lowS:r.lowS,prehash:!1},A={lowS:r.lowS,prehash:!1};function E(d,u,p=m){const{seed:x,k2sig:b}=N(d,u,p),S=r;return Be(S.hash.outputLen,S.nByteLength,S.hmac)(x,b)}h.BASE._setWindowSize(8);function z(d,u,p,x=A){var tt;const b=d;u=D("msgHash",u),p=D("publicKey",p);const{lowS:S,prehash:H,format:U}=x;if(fe(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(U!==void 0&&U!=="compact"&&U!=="der")throw new Error("format must be compact or der");const Y=typeof b=="string"||at(b),M=!Y&&!U&&typeof b=="object"&&b!==null&&typeof b.r=="bigint"&&typeof b.s=="bigint";if(!Y&&!M)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,nt;try{if(M&&(j=new Z(b.r,b.s)),Y){try{U!=="compact"&&(j=Z.fromDER(b))}catch(ft){if(!(ft instanceof $.Err))throw ft}!j&&U!=="der"&&(j=Z.fromCompact(b))}nt=h.fromHex(p)}catch{return!1}if(!j||S&&j.hasHighS())return!1;H&&(u=r.hash(u));const{r:Q,s:yt}=j,X=v(u),ot=l(yt),mt=o(X*ot),st=o(Q*ot),_=(tt=h.BASE.multiplyAndAddUnsafe(nt,mt,st))==null?void 0:tt.toAffine();return _?o(_.x)===Q:!1}return{CURVE:r,getPublicKey:B,getSharedSecret:w,sign:E,verify:z,ProjectivePoint:h,Signature:Z,utils:W}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function je(e){return{hash:e,hmac:(r,...t)=>Tt(e,r,ye(...t)),randomBytes:me}}function De(e,r){const t=n=>Ve({...e,...je(n)});return{...t(r),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ae=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ce=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ke=BigInt(0),Ye=BigInt(1),Zt=BigInt(2),ue=(e,r)=>(e+r/Zt)/r;function We(e){const r=ae,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),f=BigInt(44),o=BigInt(88),l=e*e*e%r,h=l*l*e%r,I=K(h,t,r)*h%r,R=K(I,t,r)*h%r,L=K(R,Zt,r)*l%r,k=K(L,i,r)*L%r,g=K(k,s,r)*k%r,P=K(g,f,r)*g%r,Z=K(P,o,r)*P%r,W=K(Z,f,r)*g%r,B=K(W,t,r)*h%r,c=K(B,a,r)*k%r,w=K(c,n,r)*l%r,y=K(w,Zt,r);if(!Ft.eql(Ft.sqr(y),e))throw new Error("Cannot find square root");return y}const Ft=Ot(ae,void 0,void 0,{sqrt:We}),Me=De({a:Ke,b:BigInt(7),Fp:Ft,n:ce,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const r=ce,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Ye*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,a=BigInt("0x100000000000000000000000000000000"),f=ue(s*e,r),o=ue(-n*e,r);let l=V(e-f*t-o*i,r),h=V(-f*n-o*s,r);const I=l>a,R=h>a;if(I&&(l=r-l),R&&(h=r-h),l>a||h>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:I,k1:l,k2neg:R,k2:h}}}},Ee);export{Me as secp256k1};
